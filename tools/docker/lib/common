#!/bin/bash
set -euxo pipefail

# Current supported architectures
export ALL_TARGET_ARCH=(amd64 arm32v6 arm64v8)

# Name of the Certbot Docker organizaation on GitHub. After creating
# repositories with the same names (e.g. "certbot", "dns-dnsmadeeasy", etc.)
# using a different account on Docker Hub, you can change this value to have
# the scripts modify those Docker repositories rather than the repositories for
# the official Certbot Docker images.
export DOCKER_HUB_ORG="certbot"

# List of Certbot plugins
export CERTBOT_PLUGINS=(
    "dns-dnsmadeeasy"
    "dns-dnsimple"
    "dns-ovh"
    "dns-cloudflare"
    "dns-digitalocean"
    "dns-google"
    "dns-luadns"
    "dns-nsone"
    "dns-rfc2136"
    "dns-route53"
    "dns-gehirn"
    "dns-linode"
    "dns-sakuracloud"
)

# WORK_DIR is two levels above this file
export WORK_DIR="$(realpath $(dirname ${BASH_SOURCE[0]})/..)"
# REPO_ROOT is two levels above that
export REPO_ROOT="$(realpath ${WORK_DIR}/../..)"
# location where docker cache should be created (may be anywhere accessble on the host filesystem)
export DOCKER_CACHE="${REPO_ROOT}/.docker_cache"

# Converts input architecture identifier to the platform specification
# understood by `docker build buildx --platform <specification>`.
# Usage: arch2platform [arm64|arm32v6|arm64v8]
# If the input is not recognized, an error is returned
arch2platform() {
    REQUESTED_ARCH="${1}"
    case $REQUESTED_ARCH in
        amd64)
            echo "linux/amd64"
            ;;
        arm32v6)
            echo "linux/arm/v6"
            ;;
        arm64v8)
            echo "linux/arm64"
            ;;
        *)
            return 1
            ;;
    esac
}


# Interpret the user input. Expands "all" to a list of known arches,
# and validates arches if provided with a list
InterpretArchRequest() {
    USER_INPUT="${1}"
    local IFS=","
    # Handle the special value "all"
    if [[ "${USER_INPUT}" == "all" ]]; then
        # Recursive call using the list of all known architectures cast to
        # comma separated list
        echo "${ALL_TARGET_ARCH[*]}"
        return 0
    fi
    # Convert comma separated list to array of strings
    read -ra REQUESTED_ARCH_ARRAY <<< "$USER_INPUT"
    for REQUESTED_ARCH in "${REQUESTED_ARCH_ARRAY[@]}"; do
        local IFS=" "
        if [[ ! " ${ALL_TARGET_ARCH[*]} " =~ " ${REQUESTED_ARCH} " ]]; then
            echo "unknown architecture identifier: ${REQUESTED_ARCH}"
            exit 1
        fi
    done
    echo "$USER_INPUT"
}


# Function for use with trap in the primary scripts to remove the 
# docker builder and restore the original directory
Cleanup() {
    docker builder rm certbot_builder || true
    popd
}

InstallMultiarchSupport() {
    docker run --privileged --rm tonistiigi/binfmt --install all
}

# Function to create a docker builder using the buildkit docker-container
# driver
CreateBuilder() {
    # just incase the env is not perfectly clean, remove any old instance of the builder
    docker builder rm certbot_builder || true
    # create the builder instance
    docker buildx create --name certbot_builder --driver docker-container --driver-opt=network=host --bootstrap
    # add binfmt tools to the docker environment, with integration into the new builder instance
    InstallMultiarchSupport
}
